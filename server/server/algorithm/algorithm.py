# -*- coding: utf-8 -*-
# SimplestBayesian_optimization.ipynb

# Automatically generated by Colaboratory.

# Original file is located at
#     https://colab.research.google.com/drive/1gGJwGFmZaePr2vH0mwl_JRYG20_oarh5



import numpy as np 
import time
from datetime import date
import GPy


mKernel=5 #Matern kernel order

noise_min=0.0001
kappa=5
rho_high=5 
rho_low=0.02
nrnd=1 #has to be >= 1
noise_max=0.05

np.random.seed(0)

positions= np.array([[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]])
n_chan=len(positions)

# Best known channel


# Create the kernel
# Put a  prior on the two lengthscale hyperparameters and the variance
matk = GPy.kern.Matern52(input_dim=2,variance=1.0, lengthscale=[1.0, 1.0], ARD=True, name='Mat52') 
matk.variance.set_prior(GPy.priors.Uniform(0.01**2,100**2), warning=False)
matk.lengthscale.set_prior(GPy.priors.Uniform(rho_low, rho_high), warning=False)

# Then run the sequential optimization
dim_search_space = n_chan
MaxQueries = dim_search_space
P_test =  np.zeros((dim_search_space, 2)) #storing all queries

            

q=0 # query number                                
hyp=[1.0, 1.0, 1.0, 1.0]  # initialize kernel hyperparameters               
order_this= np.random.permutation(dim_search_space) # random permutation of each entry of the search space
P_max=[] 

mean_function = GPy.core.Mapping(input_dim=2,output_dim=1)
mean_function.update_gradients = lambda a, b: None


while q < MaxQueries:
    # We will sample the search space randomly for exactly nrnd queries
    if q>=nrnd:
        # Find next point (max of acquisition function)
        acquisition_map = ymu + kappa*np.nan_to_num(np.sqrt(ys2)) # UCB acquisition function
        NextQuery= np.where(acquisition_map.reshape(len(acquisition_map))==np.max(acquisition_map.reshape(len(acquisition_map))))
        # select next query
        if len(NextQuery) > 1:
            NextQuery = NextQuery[np.random.randint(len(NextQuery))]    
        else:   
            NextQuery = NextQuery[0]
        P_test[q][0]= NextQuery[0]
    else:
        P_test[q][0]= int(order_this[q]) #
    query_elec = P_test[q][0]
    
#SEND THIS TO CLINICIAN
#RECEIVE RESPONSE

    #noisy response
    BO_reward= np.random.normal(0,0.2)
    # done reading response

    P_test[q][1]= BO_reward
    # The first element of P_test is the selected search
    # space point, the second the resulting value
                                
        
    x= positions[P_test[:q+1,0].astype(int),:] # search space position
    y= P_test[:q+1,1] # test result 
    y= y.reshape((len(y),1))

    
    # Update the initial value of the parameters  
    matk.variance= hyp[2]
    matk.lengthscale[0]= hyp[0]
    matk.lengthscale[1]= hyp[1]
        
    # Initialization of the model and the constraint of the Gaussian noise 
    if q==0:
        #m=GPy.models.GPRegression(x,y, kernel= matk, normalizer=None, noise_var=hyp[3])
        m = GPy.models.GPRegression(x,
                                                        y,
                                                        kernel=matk,
                                                        normalizer=None,
                                                        noise_var=hyp[3])
        m.Gaussian_noise.constrain_bounded(noise_min**2,noise_max**2, warning=False)
    else:
        m.set_XY(x,y)
        m.Gaussian_noise.variance[0]=hyp[3]
    
    # GP-BO optimization
    m.optimize(optimizer='scg', start= None, messages=False, max_iters=10, ipython_notebook=True,
                clear_after_finish=True)

    X_test= positions
    ymu, ys2= m.predict(X_test, full_cov=False, Y_metadata=None, include_likelihood=True)
    
    # We only test for gp predictions at electrodes that
    # we had queried (presumable we only want to return an
    # electrode that we have already queried). 
    Tested= np.unique(P_test[:q+1,0].astype(int))
    MapPredictionTested=ymu[Tested]
    BestQuery= Tested[(MapPredictionTested==np.max(MapPredictionTested)).reshape(len(MapPredictionTested))]
    
    if len(BestQuery) > 1:
        BestQuery = np.array([BestQuery[np.random.randint(len(BestQuery))]])
    # Maximum response at time q           
    P_max.append(BestQuery[0])
    q+=1

# this is a list of what square has been tested and the result obtained
print(P_test)

#this is an image of what the ground truth is, followed by what BO believes after the search
# import matplotlib.pyplot as plt

# fig = plt.figure(figsize=(10, 7))

# ymu_r = np.reshape(ymu, (-1, 4))
# plt.imshow(ymu_r)